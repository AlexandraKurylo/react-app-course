{
  "react": [
    {
      "id": "1",
      "question": "Що таке React?",
      "answer": "React — це бібліотека для створення інтерфейсів користувача.",
      "description": "React — це JavaScript-бібліотека, розроблена Meta (Facebook), яка використовується для побудови UI за допомогою компонентного підходу. React дозволяє створювати інтерфейси з окремих частин, які називаються компонентами.",
      "resources": [
        "https://react.dev",
        "https://react.dev/reference/react"
      ],
      "level": 1,
      "completed": true,
      "editDate": "03.02.2025, 19:49"
    },
    {
      "id": "2",
      "question": "Що таке JSX?",
      "answer": "JSX — це синтаксичне розширення JavaScript для React.",
      "description": "JSX дозволяє писати HTML-подібний код у JavaScript, який потім транспілюється у виклики React.createElement. Він полегшує створення та візуальне представлення структури компонентів.",
      "resources": [
        "https://react.dev/learn/writing-markup-with-jsx"
      ],
      "level": 2,
      "completed": true,
      "editDate": "03.02.2025, 20:25"
    },
    {
      "id": "3",
      "question": "Який основний принцип роботи React?",
      "answer": "React використовує Virtual DOM для оптимізації рендерингу.",
      "description": "React використовує концепцію Virtual DOM — це представлення реального DOM у пам’яті. Коли стан компонента змінюється, React порівнює Virtual DOM із попереднім станом (процес Diffing) і оновлює лише змінені елементи в реальному DOM.",
      "resources": [
        "https://react.dev/learn/render-and-commit"
      ],
      "level": 2,
      "completed": false,
      "editDate": "03.02.2025, 19:01"
    },
    {
      "id": "4",
      "question": "Як створити компонент у React?",
      "answer": "Компонент можна створити як функцію або клас.",
      "description": "Функціональні компоненти — це функції, що приймають props і повертають JSX. Класові компоненти — це класи, успадковані від React.Component, з обов'язковим методом render(). Сучасний підхід рекомендує використовувати функціональні компоненти.",
      "resources": [
        "https://react.dev/learn/your-first-component"
      ],
      "level": 1,
      "completed": false,
      "editDate": "21.02.2025, 20:26"
    },
    {
      "id": "5",
      "question": "Що таке props в React?",
      "answer": "Props — це вхідні параметри компонентів.",
      "description": "Props (властивості) використовуються для передачі даних від батьківського компонента до дочірнього. Вони є незмінними (read-only) всередині компонента, що робить компоненти більш передбачуваними та перевикористовуваними.",
      "resources": [
        "https://react.dev/learn/passing-props-to-a-component"
      ],
      "level": 1,
      "completed": false
    },
    {
      "id": "6",
      "question": "Що таке стан (state) у React?",
      "answer": "State — це внутрішні дані компонента, які можуть змінюватися.",
      "description": "Стан керується всередині компонента. Зміна стану ініціює повторний рендеринг компонента та його дітей, що дозволяє інтерфейсу реагувати на дії користувача.",
      "resources": [
        "https://react.dev/learn/state-a-components-memory"
      ],
      "level": 2,
      "completed": true
    },
    {
      "id": "7",
      "question": "Як працює useState в React?",
      "answer": "useState — це хук для управління станом у функціональних компонентах.",
      "description": "useState повертає масив із двох елементів: поточного значення стану та функції для його оновлення. Це базовий спосіб збереження реактивних даних у функціях.",
      "resources": [
        "https://react.dev/reference/react/useState"
      ],
      "level": 2,
      "completed": true
    },
    {
      "id": "8",
      "question": "Що таке useEffect?",
      "answer": "useEffect — це хук для керування побічними ефектами.",
      "description": "Хук useEffect дозволяє виконувати побічні ефекти: запити до API, підписки, таймери або маніпуляції з DOM. Він запускається після рендерингу і може бути налаштований на виконання лише при зміні певних залежностей.",
      "resources": [
        "https://react.dev/reference/react/useEffect"
      ],
      "level": 2,
      "completed": true
    },
    {
      "id": "9",
      "question": "Що таке React Router?",
      "answer": "React Router — це бібліотека для маршрутизації в React-додатках.",
      "description": "Він дозволяє реалізувати навігацію без перезавантаження сторінки (SPA), надаючи компоненти BrowserRouter, Routes, Route та Link. Підтримує вкладені маршрути та динамічні параметри.",
      "resources": [
        "https://reactrouter.com/en/main"
      ],
      "level": 2,
      "completed": false
    },
    {
      "id": "10",
      "question": "Як оптимізувати продуктивність програми React?",
      "answer": "Використовуйте React.memo, useMemo, useCallback та оптимізацію рендерингу.",
      "description": "Для підвищення продуктивності використовують мемоізацію, Code Splitting (розділення коду) через React.lazy, оптимізацію списків за допомогою ключів та запобігання зайвим рендерам.",
      "resources": [
        "https://react.dev/learn/keeping-components-pure"
      ],
      "level": 3,
      "completed": true
    },
    {
      "id": "11",
      "question": "Що таке Virtual DOM в React?",
      "answer": "Virtual DOM — це легка копія реального DOM у пам'яті.",
      "description": "Це концепція, де «віртуальне» представлення інтерфейсу зберігається в пам'яті та синхронізується з «реальним» DOM за допомогою бібліотеки ReactDOM (процес Reconciliation).",
      "resources": [
        "https://react.dev/learn/render-and-commit"
      ],
      "level": 2,
      "completed": false
    },
    {
      "id": "12",
      "question": "Як працює React.memo?",
      "answer": "React.memo — це HOC для мемоізації функціональних компонентів.",
      "description": "Він запобігає повторному рендерингу компонента, якщо його пропси не змінилися. Це корисно для великих компонентів, чиї батьки часто оновлюються.",
      "resources": [
        "https://react.dev/reference/react/memo"
      ],
      "level": 3,
      "completed": false
    },
    {
      "id": "13",
      "question": "Що робить useCallback?",
      "answer": "useCallback кешує визначення функції між рендерами.",
      "description": "Цей хук повертає мемоізовану версію колбеку, яка змінюється лише тоді, коли змінюються значення в списку залежностей. Це запобігає зайвим рендерам дочірніх компонентів, які залежать від посилальної рівності функцій.",
      "resources": [
        "https://react.dev/reference/react/useCallback"
      ],
      "level": 3,
      "completed": false
    },
    {
      "id": "14",
      "question": "Що робить useMemo?",
      "answer": "useMemo мемоізує результат обчислень.",
      "description": "Він повторно обчислює значення лише тоді, коли змінюється одна із залежностей. Це допомагає уникнути дорогих розрахунків при кожному рендерингу.",
      "resources": [
        "https://react.dev/reference/react/useMemo"
      ],
      "level": 3,
      "completed": false
    },
    {
      "id": "15",
      "question": "Як працює обробка подій у React?",
      "answer": "React використовує систему синтетичних подій (SyntheticEvent).",
      "description": "Події в React — це кросбраузерні обгортки навколо нативних подій браузера. Вони мають той самий інтерфейс, що й нативні події, але працюють однаково в усіх браузерах.",
      "resources": [
        "https://react.dev/learn/responding-to-events"
      ],
      "level": 2,
      "completed": true
    },
    {
      "id": "16",
      "question": "Що таке портали (Portals) у React?",
      "answer": "Портали дозволяють рендерити дочірні елементи в інший DOM-вузол.",
      "description": "За допомогою ReactDOM.createPortal можна винести компонент (наприклад, модальне вікно) за межі батьківського DOM-ієрархії, зберігаючи при цьому логічний зв'язок у дереві React.",
      "resources": [
        "https://react.dev/reference/react-dom/createPortal"
      ],
      "level": 3,
      "completed": false
    },
    {
      "id": "17",
      "question": "Як реалізувати ліниве завантаження компонентів?",
      "answer": "Використовуйте React.lazy та Suspense.",
      "description": "React.lazy дозволяє визначати компонент, який завантажується динамічно. Suspense дозволяє відображати резервний контент (наприклад, лоадер), поки триває завантаження.",
      "resources": [
        "https://react.dev/reference/react/lazy"
      ],
      "level": 2,
      "completed": false
    },
    {
      "id": "18",
      "question": "Що таке Context API?",
      "answer": "Context API — це механізм передачі даних через дерево компонентів без прокидання пропсів (prop drilling).",
      "description": "Використовується для керування глобальними даними, такими як поточна тема, мова або авторизований користувач.",
      "resources": [
        "https://react.dev/reference/react/createContext"
      ],
      "level": 2,
      "completed": false
    },
    {
      "id": "19",
      "question": "Як використовувати useContext?",
      "answer": "useContext дозволяє отримувати значення з контексту у функціональних компонентах.",
      "description": "Хук приймає об'єкт контексту і повертає його поточне значення, автоматично підписуючи компонент на оновлення цього контексту.",
      "resources": [
        "https://react.dev/reference/react/useContext"
      ],
      "level": 2,
      "completed": false
    },
    {
      "id": "20",
      "question": "Що таке рендер-пропси (Render Props)?",
      "answer": "Render props — це патерн проектування, де пропс приймає функцію для рендерингу.",
      "description": "Цей метод дозволяє компоненту ділитися логікою з іншими компонентами, передаючи стан через аргументи функції-пропса.",
      "resources": [
        "https://react.dev/learn/render-props"
      ],
      "level": 3,
      "completed": false
    },
    {
      "id": "21",
      "question": "Як оновити стан у класовому компоненті?",
      "answer": "За допомогою методу setState.",
      "description": "setState планує оновлення об'єкта стану компонента. Коли стан змінюється, компонент рендериться повторно. Метод може приймати функцію для надійного оновлення на основі попереднього стану.",
      "resources": [
        "https://react.dev/reference/react/Component#setstate"
      ],
      "level": 1,
      "completed": true
    },
    {
      "id": "22",
      "question": "Як працювати з формами в React?",
      "answer": "Використовуйте керовані (controlled) та некеровані (uncontrolled) компоненти.",
      "description": "У керованих компонентах стан поля введення зберігається в state React. У некерованих — дані зчитуються безпосередньо з DOM за допомогою ref.",
      "resources": [
        "https://react.dev/learn/sharing-state-between-components"
      ],
      "level": 2,
      "completed": false
    },
    {
      "id": "23",
      "question": "Як передати ref до дочірнього компонента?",
      "answer": "Використовуйте forwardRef.",
      "description": "React.forwardRef дозволяє батьківському компоненту отримати посилання (ref) на DOM-вузол або екземпляр всередині дочірнього компонента.",
      "resources": [
        "https://react.dev/reference/react/forwardRef"
      ],
      "level": 3,
      "completed": false
    },
    {
      "id": "24",
      "question": "Для чого потрібні ключі (keys) у списках?",
      "answer": "Ключі допомагають React ідентифікувати, які елементи змінилися, були додані або видалені.",
      "description": "Ключі повинні бути стабільними та унікальними серед сусідніх елементів. Це критично важливо для продуктивності та коректного збереження стану компонентів у списках.",
      "resources": [
        "https://react.dev/learn/rendering-lists"
      ],
      "level": 1,
      "completed": false
    },
    {
      "id": "25",
      "question": "Що робить Strict Mode?",
      "answer": "StrictMode — це інструмент для виявлення потенційних проблем у додатку.",
      "description": "Він не рендерить видимий UI, але активує додаткові перевірки та попередження для розробника (наприклад, подвійний виклик ефектів у dev-режимі).",
      "resources": [
        "https://react.dev/reference/react/StrictMode"
      ],
      "level": 2,
      "completed": false
    },
    {
      "id": "26",
      "question": "Як працює useReducer?",
      "answer": "useReducer керує складним станом через редьюсер-функцію.",
      "description": "Цей хук є альтернативою useState. Він краще підходить для логіки стану, що включає кілька підзначень, або коли наступний стан залежить від попереднього.",
      "resources": [
        "https://react.dev/reference/react/useReducer"
      ],
      "level": 3,
      "completed": false
    },
    {
      "id": "27",
      "question": "Як відловлювати помилки в React-компонентах?",
      "answer": "Використовуйте запобіжники (Error Boundaries).",
      "description": "Це класові компоненти, які реалізують методи життєвого циклу для перехоплення помилок у дереві дочірніх компонентів, щоб запобігти падінню всього додатка.",
      "resources": [
        "https://react.dev/learn/error-handling"
      ],
      "level": 3,
      "completed": false
    },
    {
      "id": "28",
      "question": "Що робить хук useRef?",
      "answer": "useRef створює об'єкт-посилання, значення якого зберігається між рендерами.",
      "description": "Використовується для доступу до DOM-елементів або для збереження будь-яких мутабельних значень, зміна яких не повинна викликати повторний рендеринг.",
      "resources": [
        "https://react.dev/reference/react/useRef"
      ],
      "level": 2,
      "completed": false
    },
    {
      "id": "29",
      "question": "Як реалізувати серверний рендеринг (SSR) у React?",
      "answer": "Використовуйте фреймворки на кшталт Next.js або бібліотеку ReactDOMServer.",
      "description": "SSR дозволяє генерувати HTML на сервері, що прискорює перше відображення та покращує індексацію пошуковими системами (SEO).",
      "resources": [
        "https://nextjs.org/docs"
      ],
      "level": 3,
      "completed": false
    },
    {
      "id": "30",
      "question": "Що таке фрагменти (React Fragments)?",
      "answer": "Фрагменти дозволяють групувати список дочірніх елементів без додавання зайвого вузла в DOM.",
      "description": "Використовуються, коли потрібно повернути кілька елементів із компонента. Скорочений синтаксис: <></>.",
      "resources": [
        "https://react.dev/reference/react/Fragment"
      ],
      "level": 1,
      "completed": false
    },
    {
      "id": "31",
      "question": "Як використовувати useLayoutEffect?",
      "answer": "useLayoutEffect виконується синхронно після всіх мутацій DOM, але до того, як браузер відмалює зміни.",
      "description": "Він ідентичний useEffect за синтаксисом, але використовується для вимірювання DOM (наприклад, ширини елемента) та негайного оновлення UI без «миготіння».",
      "resources": [
        "https://react.dev/reference/react/useLayoutEffect"
      ],
      "level": 3,
      "completed": false
    },
    {
      "id": "32",
      "question": "Як працює useImperativeHandle?",
      "answer": "useImperativeHandle налаштовує значення рефу, яке бачить батьківський компонент.",
      "description": "Зазвичай використовується разом із forwardRef для того, щоб надати батькові доступ лише до певних методів дочірнього компонента (наприклад, focus() або scrollIntoView()).",
      "resources": [
        "https://react.dev/reference/react/useImperativeHandle"
      ],
      "level": 3,
      "completed": false
    },
    {
      "id": "33",
      "question": "Що таке HOC (Higher-Order Component)?",
      "answer": "HOC — це функція, яка приймає компонент і повертає новий розширений компонент.",
      "description": "Це патерн для повторного використання логіки компонентів. Хоча в сучасному React хуки замінили більшість випадків використання HOC, він все ще зустрічається в старіших бібліотеках.",
      "resources": [
        "https://react.dev/learn/reusing-logic-with-custom-hooks"
      ],
      "level": 3,
      "completed": false
    },
    {
      "id": "34",
      "question": "Як створити глобальний стан у React?",
      "answer": "Використовуйте Context API або зовнішні бібліотеки (Redux, Zustand, MobX).",
      "description": "Для простих завдань підходить Context API. Для великих додатків зі складною логікою використовують Redux Toolkit або легший Zustand.",
      "resources": [
        "https://react.dev/learn/passing-data-deeply-with-context",
        "https://redux.js.org"
      ],
      "level": 3,
      "completed": true
    },
    {
      "id": "35",
      "question": "Що таке React Fiber?",
      "answer": "React Fiber — це архітектура та алгоритм рендерингу, впроваджений у React 16.",
      "description": "Він дозволяє React розбивати процес рендерингу на частини та пріоритезувати оновлення (наприклад, анімації мають вищий пріоритет, ніж завантаження даних), роблячи інтерфейс плавнішим.",
      "resources": [
        "https://react.dev/blog/2017/09/26/react-v16.0.html"
      ],
      "level": 3,
      "completed": false
    },
    {
      "id": "36",
      "question": "Як працює React Suspense?",
      "answer": "Suspense дозволяє компонентам «чекати» завершення асинхронних операцій перед рендерингом.",
      "description": "Він використовується для ленивого завантаження компонентів та (в нових версіях) для очікування даних з API, відображаючи fallback-інтерфейс (наприклад, скелетон).",
      "resources": [
        "https://react.dev/reference/react/Suspense"
      ],
      "level": 3,
      "completed": false
    },
    {
      "id": "37",
      "question": "Що таке Concurrent Mode у React?",
      "answer": "Це набір можливостей для покращення чуйності інтерфейсу.",
      "description": "Дозволяє React працювати над кількома оновленнями одночасно, не блокуючи основний потік браузера для взаємодії з користувачем.",
      "resources": [
        "https://react.dev/blog/2021/06/08/the-plan-for-react-18"
      ],
      "level": 3,
      "completed": false
    },
    {
      "id": "38",
      "question": "Як використовувати React DevTools?",
      "answer": "Це розширення для браузера для налагодження React-додатків.",
      "description": "Воно дозволяє досліджувати дерево компонентів, перевіряти поточні пропси та стан, а також аналізувати продуктивність через вкладку Profiler.",
      "resources": [
        "https://react.dev/learn/react-developer-tools"
      ],
      "level": 1,
      "completed": false
    },
    {
      "id": "39",
      "question": "Що таке React Server Components (RSC)?",
      "answer": "Це компоненти, які виконуються виключно на сервері.",
      "description": "RSC дозволяють зменшити розмір клієнтського бандла, оскільки код самих компонентів не завантажується в браузер. Вони мають прямий доступ до бази даних та файлової системи.",
      "resources": [
        "https://react.dev/blog/2020/12/21/data-fetching-with-react-server-components"
      ],
      "level": 3,
      "completed": false
    },
    {
      "id": "40",
      "question": "Як використовувати React з TypeScript?",
      "answer": "TypeScript додає статичну типізацію до React-додатків.",
      "description": "Це допомагає уникати помилок на етапі розробки, чітко описуючи форму пропсів, стану та повернених значень хуків. Використовуються вбудовані типи, як-от React.FC або React.ReactNode.",
      "resources": [
        "https://react.dev/learn/typescript"
      ],
      "level": 2,
      "completed": false
    },
    {
      "id": "41",
      "question": "Що таке React Hooks?",
      "answer": "Хуки — це спеціальні функції, які дають змогу «підчепитися» до можливостей React у функціональних компонентах.",
      "description": "Вони з'явилися у версії 16.8 і дозволяють використовувати стан, контекст та методи життєвого циклу без написання класів.",
      "resources": [
        "https://react.dev/reference/react"
      ],
      "level": 2,
      "completed": false
    },
    {
      "id": "42",
      "question": "Як використовувати React з Redux?",
      "answer": "Через офіційну бібліотеку react-redux.",
      "description": "Вона надає хуки useSelector для отримання даних зі сховища та useDispatch для відправки екшенів. Рекомендується використовувати Redux Toolkit (RTK) як сучасний стандарт.",
      "resources": [
        "https://react-redux.js.org"
      ],
      "level": 3,
      "completed": false
    },
    {
      "id": "43",
      "question": "Що таке React Testing Library?",
      "answer": "Це бібліотека для тестування компонентів, орієнтована на поведінку користувача.",
      "description": "На відміну від Enzyme, вона заохочує тестувати те, що бачить користувач, а не внутрішню реалізацію компонентів (наприклад, пошук тексту на кнопці замість перевірки стану).",
      "resources": [
        "https://testing-library.com/docs/react-testing-library/intro"
      ],
      "level": 2,
      "completed": false
    },
    {
      "id": "44",
      "question": "Як використовувати React з GraphQL?",
      "answer": "Зазвичай за допомогою клієнтів Apollo Client або Relay.",
      "description": "Ці бібліотеки надають хуки (наприклад, useQuery) для отримання даних, керують кешуванням та автоматично оновлюють UI при зміні даних у GraphQL API.",
      "resources": [
        "https://www.apollographql.com/docs/react"
      ],
      "level": 3,
      "completed": false
    },
    {
      "id": "45",
      "question": "Що таке React Native?",
      "answer": "Фреймворк для створення мобільних додатків на JavaScript.",
      "description": "Він використовує ті ж принципи, що й React, але замість рендерингу в браузерний DOM використовує нативні компоненти iOS та Android.",
      "resources": [
        "https://reactnative.dev"
      ],
      "level": 2,
      "completed": false
    },
    {
      "id": "46",
      "question": "Як використовувати React з Webpack?",
      "answer": "Webpack виступає як збирач модулів (bundler).",
      "description": "Для роботи з React у Webpack налаштовується babel-loader (для транспіляції JSX та сучасного JS), а також плагіни для обробки стилів та статичних файлів.",
      "resources": [
        "https://webpack.js.org/guides/getting-started"
      ],
      "level": 3,
      "completed": false
    },
    {
      "id": "47",
      "question": "Що таке Error Boundaries (повторно)?",
      "answer": "Це механізм відловлювання помилок рендерингу.",
      "description": "Використовуються методи getDerivedStateFromError (для оновлення стану та показу запасного UI) та componentDidCatch (для логування помилок).",
      "resources": [
        "https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary"
      ],
      "level": 3,
      "completed": false
    },
    {
      "id": "48",
      "question": "Як використовувати React з CSS-in-JS?",
      "answer": "Через бібліотеки styled-components, Emotion або Vanilla Extract.",
      "description": "Стилі пишуться безпосередньо в JS/TS файлах, що дозволяє використовувати пропси для динамічної стилізації та забезпечує повну ізоляцію класів.",
      "resources": [
        "https://styled-components.com"
      ],
      "level": 2,
      "completed": false
    },
    {
      "id": "49",
      "question": "Що таке Concurrent Rendering?",
      "answer": "Можливість React переривати рендеринг для обробки термінових завдань.",
      "description": "Це дозволяє системі залишатися чуйною до введення користувача, навіть якщо в цей момент рендериться складний список компонентів.",
      "resources": [
        "https://react.dev/blog/2021/06/08/the-plan-for-react-18"
      ],
      "level": 3,
      "completed": false
    },
    {
      "id": "50",
      "question": "Як поєднувати SSR та CSR?",
      "answer": "Це називається гідратацією (Hydration).",
      "description": "Сервер надсилає готовий HTML (SSR), а потім React «оживляє» його в браузері (CSR), підключаючи обробники подій та стан. Next.js автоматично керує цим процесом.",
      "resources": [
        "https://nextjs.org/docs"
      ],
      "level": 3,
      "completed": false
    }
  ]
}
